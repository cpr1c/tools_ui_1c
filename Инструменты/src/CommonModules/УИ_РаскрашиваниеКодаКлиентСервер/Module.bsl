
// Процедура раскрашивания текста
// 
Функция РаскраситьТекст(Текст) Экспорт
	ВСтроке = Ложь;
	ОткрывающиеТеги = ОткрывающиеТеги();
	КлючевыеСлова = КлючевыеСлова();
	Операторы = Операторы();

	РаскрашенныйКод=РаскрашенныйМногострочныйКод(Текст, КлючевыеСлова, Операторы, ОткрывающиеТеги, ВСтроке);

	Возврат СтрШаблон(
		"<!DOCTYPE html>
		|<HTML>
		|<HEAD>
		|<TITLE>Код с оформлением</TITLE>
		|</HEAD>
		|<BODY>
		|<PRE style=""color: blue;font-family: """"Consolas"""";font-size: 10pt;""><CODE class=""language-1c"">%1</CODE></PRE>
		|</BODY>
		|</HTML>", РаскрашенныйКод);
КонецФункции

// Возвращает соответствие из открывающих тегов для раскраски кода.
Функция ОткрывающиеТеги()
	Результат = Новый Соответствие;
	Результат.Вставить("КлючевоеСлово", "<font color=red>");
	Результат.Вставить("Комментарий", "<font color=green>");
	Результат.Вставить("Строка", "<font color=black>");
	Результат.Вставить("Число", "<font color=black>");
	Результат.Вставить("Препроцессор", "<font color=brown>");
	Возврат Результат;
КонецФункции

// Возвращает соответствие ключевых слов встроенного языка.
//
// Возвращаемое значение:
//   Соответствие - Ключевые слова встроенного языка в нижнем регистре.
//       * Ключ - Строка - Ключевое слово.
//       * Значение - Булево - Истина для всех ключевых слов.
//
Функция КлючевыеСлова()
	Массив = Новый Массив;
	Массив.Добавить("if");
	Массив.Добавить("если");
	Массив.Добавить("then");
	Массив.Добавить("тогда");
	Массив.Добавить("elsif");
	Массив.Добавить("иначеесли");
	Массив.Добавить("else");
	Массив.Добавить("иначе");
	Массив.Добавить("endif");
	Массив.Добавить("конецесли");
	Массив.Добавить("do");
	Массив.Добавить("цикл");
	Массив.Добавить("for");
	Массив.Добавить("для");
	Массив.Добавить("to");
	Массив.Добавить("по");
	Массив.Добавить("each");
	Массив.Добавить("каждого");
	Массив.Добавить("in");
	Массив.Добавить("из");
	Массив.Добавить("while");
	Массив.Добавить("пока");
	Массив.Добавить("endDo");
	Массив.Добавить("конеццикла");
	Массив.Добавить("procedure");
	Массив.Добавить("процедура");
	Массив.Добавить("endprocedure");
	Массив.Добавить("конецпроцедуры");
	Массив.Добавить("function");
	Массив.Добавить("функция");
	Массив.Добавить("endfunction");
	Массив.Добавить("конецфункции");
	Массив.Добавить("var");
	Массив.Добавить("перем");
	Массив.Добавить("export");
	Массив.Добавить("экспорт");
	Массив.Добавить("goto");
	Массив.Добавить("перейти");
	Массив.Добавить("and");
	Массив.Добавить("и");
	Массив.Добавить("or");
	Массив.Добавить("или");
	Массив.Добавить("not");
	Массив.Добавить("не");
	Массив.Добавить("val");
	Массив.Добавить("знач");
	Массив.Добавить("break");
	Массив.Добавить("прервать");
	Массив.Добавить("continue");
	Массив.Добавить("продолжить");
	Массив.Добавить("return");
	Массив.Добавить("возврат");
	Массив.Добавить("try");
	Массив.Добавить("попытка");
	Массив.Добавить("except");
	Массив.Добавить("исключение");
	Массив.Добавить("endTry");
	Массив.Добавить("конецпопытки");
	Массив.Добавить("raise");
	Массив.Добавить("вызватьисключение");
	Массив.Добавить("false");
	Массив.Добавить("ложь");
	Массив.Добавить("true");
	Массив.Добавить("истина");
	Массив.Добавить("undefined");
	Массив.Добавить("неопределено");
	Массив.Добавить("null");
	Массив.Добавить("new");
	Массив.Добавить("новый");
	Массив.Добавить("execute");
	Массив.Добавить("выполнить");

	Соответствие = Новый Соответствие;
	Для Каждого Элемент Из Массив Цикл
		Соответствие.Вставить(Элемент, Истина);
	КонецЦикла;
	Возврат Соответствие;
КонецФункции

// Возвращает соответствие операторов встроенного языка.
//
// Возвращаемое значение:
//   Соответствие - Операторы встроенного языка.
//       * Ключ - Строка - Оператор.
//       * Значение - Булево - Истина для всех операторов.
//
Функция Операторы()
	Массив = Новый Массив;
	Массив.Добавить(")");
	Массив.Добавить("(");
	Массив.Добавить("[");
	Массив.Добавить("]");
	Массив.Добавить(".");
	Массив.Добавить(",");
	Массив.Добавить("=");
	Массив.Добавить("+");
	Массив.Добавить("-");
	Массив.Добавить("<");
	Массив.Добавить(">");
	Массив.Добавить(";");
	Массив.Добавить("?");
	Массив.Добавить("*");

	Соответствие = Новый Соответствие;
	Для Каждого Элемент Из Массив Цикл
		Соответствие.Вставить(Элемент, Истина);
	КонецЦикла;
	Возврат Соответствие;
КонецФункции

// Функция последовательно перебирает все строки переданного кода
// 
// Параметры:
//   Код - Код, который подлежит окраске
//
// Возвращаемое значение:
//   Буфер - Окрашенный код, заключенный в тег <pre>
//
Функция РаскрашенныйМногострочныйКод(Код, КлючевыеСлова, Операторы, ОткрывающиеТеги, ВСтроке)

	Буфер = "";
	
	// Последовательно перебираются все строки кода, окрашиваются
	// и записываются в буфер
	Для счт = 1 По СтрЧислоСтрок(Код) Цикл

		стр = СтрПолучитьСтроку(Код, счт);
		Буфер = Буфер + РаскраситьСтрокуКода(стр, КлючевыеСлова, Операторы, ОткрывающиеТеги, ВСтроке) + Символы.ПС;

	КонецЦикла;

	Возврат Буфер;

КонецФункции

// Функция получения символа из строки в заданной позиции
// 
// Параметры:
//   Строка - Строка, из которой берется символ
//   Поз    - Позиция получаемого символа в строке
//
// Возвращаемое значение:
//   Символ из запрашиваемой позиции
//
Функция ПолучитьСимвол(Строка, Поз)

	Возврат Сред(Строка, Поз, 1);

КонецФункции

// Токен проверяется на принадлежность к ключевым словам встроенного языка
//
// Параметры:
//   Токен - Строка - проверяемый токен
//
// Возвращаемое значение:
//   Булево - Истина, если токен является ключевым словом встроенного языка, Ложь - не является.
//
Функция ЭтоКлючевоеСлово(Токен, КлючевыеСлова)
	Возврат КлючевыеСлова[НРег(Токен)] = Истина;
КонецФункции

// Проверяется символ на принадлежность к специальным символам
//
// Параметры:
//   Символ - Строка - Проверяемый символ
//
// Возвращаемое значение:
//   Булево - Истина, если Символ является специальным символом, Ложь - не является.
//
Функция ЭтоОператор(Символ, Операторы)
	Возврат Операторы[Символ] = Истина;
КонецФункции

// Процедура раскраски токена.
//
// Параметры:
//   СтрокаКода - Текущая строка кода
//   Токен      - Токен, который окрашивается
//   Поз        - Позиция начала Токена в текущей строке
//   Класс      - Класс, к которому принадлежит токен
//
Процедура РаскраситьТокен(СтрокаКода, Токен, Поз, Класс, ОткрывающиеТеги)

	ДлинаТокена = СтрДлина(Токен);

	СтрокаКода = Лев(СтрокаКода, Поз - ДлинаТокена) + ОткрывающиеТеги[Класс] + Сред(СтрокаКода, Поз - ДлинаТокена + 1,
		ДлинаТокена) + "</font>" + Прав(СтрокаКода, СтрДлина(СтрокаКода) - Поз);
	Поз = Поз + СтрДлина(ОткрывающиеТеги[Класс] + "</font>");

КонецПроцедуры

// Основная функция раскрашивания кода.
//
// Параметры:
//   СтрокаКода - Строка - Раскрашивание происходит построчно, этот параметр - текущая строка.
//
// Возвращаемое значение:
//   Строка - Раскрашенная строка кода.
//
Функция РаскраситьСтрокуКода(СтрокаКода, КлючевыеСлова, Операторы, ОткрывающиеТеги, ВСтроке)

	Поз = 1;
	Токен = "";
	НачалоСтроки = 1;
	
	// Последовательно перебираются все символы строки кода
	Пока Поз <> СтрДлина(СтрокаКода) + 1 Цикл

		ТекущийСимвол = ПолучитьСимвол(СтрокаКода, Поз);
		Если ТекущийСимвол = "/" Тогда
			
			// Проверяется на комментарий или на символ деления
			Если Не ВСтроке Тогда
				Если ПолучитьСимвол(СтрокаКода, Поз + 1) = "/" Тогда
					// Окрашиваем комментарий
					СтрокаКода = Лев(СтрокаКода, Поз - 1) + ОткрывающиеТеги["Комментарий"] + Прав(СтрокаКода, СтрДлина(
						СтрокаКода) - Поз + 1) + "</font>";
					Возврат СтрокаКода;
				Иначе
					// Это символ деления
					РаскраситьТокен(СтрокаКода, ТекущийСимвол, Поз, "КлючевоеСлово", ОткрывающиеТеги);
					Токен = "";
				КонецЕсли;
			КонецЕсли;

		ИначеЕсли ТекущийСимвол = Символы.Таб Или ТекущийСимвол = " " Тогда
			
			// Операции при встрече символа табуляции или пробела
			Если Не ВСтроке Тогда
				Если Не ПустаяСтрока(Токен) Тогда
					Поз = Поз - 1;
					// Пробел после после токена, значит
					// токен - ключевое слово...
					Если ЭтоКлючевоеСлово(Токен, КлючевыеСлова) Тогда
						РаскраситьТокен(СтрокаКода, Токен, Поз, "КлючевоеСлово", ОткрывающиеТеги);
					Иначе
						// ... или число
						Попытка
							//@skip-warning
							ч = Число(Токен);
							РаскраситьТокен(СтрокаКода, Токен, Поз, "Число", ОткрывающиеТеги);
						Исключение
						КонецПопытки;
					КонецЕсли;
					Поз = Поз + 1;
					Токен = "";
				КонецЕсли;
			КонецЕсли;

		ИначеЕсли ТекущийСимвол = """" Тогда

			Если ВСтроке Тогда
				// Нашли парную кавычку - окрашиваем как строку
				СтрокаКода = Лев(СтрокаКода, НачалоСтроки - 1) + ОткрывающиеТеги["Строка"] + Сред(СтрокаКода,
					НачалоСтроки, Поз - НачалоСтроки + 1) + "</font>" + Прав(СтрокаКода, СтрДлина(СтрокаКода) - Поз);
				Поз = Поз + СтрДлина(ОткрывающиеТеги["Строка"] + "</font>");
				ВСтроке = Ложь;
				Токен = "";
			Иначе
				// Первая кавычка, запоминаем позицию и взводим флаг нахождения в строке
				НачалоСтроки = Поз;
				ВСтроке = Истина;
			КонецЕсли;

		ИначеЕсли ТекущийСимвол = "" Тогда

			Прервать;

		ИначеЕсли ЭтоОператор(ТекущийСимвол, Операторы) Тогда
			
			// Встретился один из специальных символов
			Если Не ВСтроке Тогда
				Если Не ПустаяСтрока(Токен) Тогда
					Поз = Поз - 1;
					// Дабы избежать окраски метода объекта с совпадающим
					// именем с одним из ключевых слов, проверяем текущий символ
					// на "."
					Если ЭтоКлючевоеСлово(Токен, КлючевыеСлова) И ТекущийСимвол <> "." Тогда
						РаскраситьТокен(СтрокаКода, Токен, Поз, "КлючевоеСлово", ОткрывающиеТеги);
					Иначе
						// Не ключевое слово - значит число
						Попытка
							ч = Число(Токен);
							РаскраситьТокен(СтрокаКода, Токен, Поз, "Число", ОткрывающиеТеги);
						Исключение
						КонецПопытки;
					КонецЕсли;
					Поз = Поз + 1;
					Токен = "";
				КонецЕсли;
				// Один из специальных символов
				РаскраситьТокен(СтрокаКода, ТекущийСимвол, Поз, "КлючевоеСлово", ОткрывающиеТеги);
			КонецЕсли;

		ИначеЕсли ТекущийСимвол = "#" Или ТекущийСимвол = "&" Тогда
			
			// Встретился символ препроцессора
			Если Не ВСтроке Тогда
				Поз = СтрДлина(СтрокаКода);
				РаскраситьТокен(СтрокаКода, СтрокаКода, Поз, "Препроцессор", ОткрывающиеТеги);
			КонецЕсли;

		Иначе
			
			// Остальные символы
			Токен = Токен + ТекущийСимвол;

		КонецЕсли;

		Поз = Поз + 1;
	КонецЦикла;
	
	// Многострочная строка
	Если ВСтроке Тогда
		СтрокаКода = Лев(СтрокаКода, НачалоСтроки - 1) + ОткрывающиеТеги["Строка"] + Сред(СтрокаКода, НачалоСтроки, Поз
			- НачалоСтроки + 1) + "</font>" + Прав(СтрокаКода, СтрДлина(СтрокаКода) - Поз);
		Поз = Поз + СтрДлина(ОткрывающиеТеги["Строка"] + "</font>");
		Токен = "";
	КонецЕсли;
	
	// Анализируем последний токен строки кода
	Если Не ПустаяСтрока(Токен) Тогда
		Если ЭтоКлючевоеСлово(Токен, КлючевыеСлова) Тогда
			Поз = Поз - 1;
			РаскраситьТокен(СтрокаКода, Токен, Поз, "КлючевоеСлово", ОткрывающиеТеги);
			Поз = Поз + 1;
		КонецЕсли;
	КонецЕсли;

	Возврат СтрокаКода;

КонецФункции